% Info
% 1. change speed value per samples
%    (ux : 1~3, uy : -0.5~0.5)
% 2. Generate 1 obstacle of 3 edge
%   - x-axis 0~1.5, y-axis 0~1.5
%   - minimum position of x : width*0.20
%   - maximum position of x : width*0.80
%   - minimum position of y : width*0.20
%   - maximum position of y : width*0.80
% 3. save : ux, uy, pressure, subd, solve

% argument setting
cOptDef = {   ...
    'width',     3; % length of x-axis
    'height',    1.5; % length of y-axis
    'Ux_from',    1; % length of y-axis
    'Ux_to',    3; % length of y-axis
    'Uy_from',    -0.5; % length of y-axis
    'Uy_to',    0.5; % length of y-axis
    'Ux_path',  'Dataset/basic_3edges/Ux/';
    'Uy_path',   'Dataset/basic_3edges/Uy/';
    'P_path',    'Dataset/basic_3edges/Pressure/';
    'Solve_path', 'Dataset/basic_3edges/Solve/';
    'Subd_path', 'Dataset/basic_3edges/Subd/';
    };

% opt has value of argument setting
[got,opt] = parseopt(cOptDef);

for step = 1:1:100

    clf('reset')
    clearvars -except step opt
    
    % set velocity
    Ux_Velocity = round(opt.Ux_from + (opt.Ux_to-(opt.Ux_from)) * rand(),2);
    Ux_Velocity_str = string(Ux_Velocity);
    Uy_Velocity = round(opt.Uy_from + (opt.Uy_to-(opt.Uy_from)) * rand(),2);
    Uy_Velocity_str = string(Uy_Velocity);

    % set saved name
    save_name_temp = strcat(int2str(step),"_ux_"); % 0_ux_
    save_name_temp = strcat(save_name_temp,Ux_Velocity_str); % 0_ux_ux-value
    save_name_temp = strcat(save_name_temp,"_uy_"); % 0_ux_ux-value_uy_
    save_name_temp = strcat(save_name_temp,Uy_Velocity_str); % 0_ux_ux-value_uy_uy-value
    save_name = strcat('3edges_',save_name_temp) % 3edges_0_ux_ux-value_uy_uy-value

    % feature setting
    fea.sdim = { 'x', 'y' };
    fea = addphys( fea, @navierstokes, { 'u', 'v', 'p' } );
    gobj = gobj_rectangle( 0, opt.width, 0, opt.height, 'R1');

    % geometry
    x_lim = [0, opt.width];
    y_lim = [0, opt.height];
    
    % setting of obstacle
    size_factor = 0.3;

    % generate a single triangle
    offset = generate_random_offset(opt.width*0.2, opt.width*0.8, opt.height*0.2, opt.height*0.8, size_factor);
    rotation_angle = rand() * 2 * pi; % Random rotation angle between 0 and 360 degrees
    triangle = generate_triangle(offset, size_factor, rotation_angle)';

    % final geometry
    fea = geom_add_gobj( fea, gobj );
    gobj = gobj_polygon( triangle, 'P1');
    fea = geom_add_gobj( fea, gobj );
    fea.geom = geom_apply_formula( fea.geom, 'R1-P1' );

    % grid and refine
    fea.grid = gridgen( fea, 'gridgen', 'default', 'hmax', 0.075, 'grading', 0.3 );
    fea = gridrefine( fea );
    fea = gridrefine( fea );

    %% Equation settings
    fea.phys.ns.dvar = { 'u', 'v', 'p' };
    fea.phys.ns.sfun = { 'sflag1', 'sflag1', 'sflag1' };
    fea.phys.ns.eqn.coef = { 'rho_ns', 'rho', 'Density', { '1' };
                             'miu_ns', 'mu', 'Viscosity', { '1' };
                             'Fx_ns', 'F_x', 'Volume force in x-direction', { '0' };
                             'Fy_ns', 'F_y', 'Volume force in y-direction', { '0' };
                             'u0_ns', 'u_0', 'Initial condition for u', { '0' };
                             'v0_ns', 'v_0', 'Initial condition for v', { '0' };
                             'p0_ns', 'p_0', 'Initial condition for p', { '0' };
                             'miuT_ns', [], 'Turbulent viscosity', { 0 } };
    fea.phys.ns.eqn.sdiff = { ' - (miu_ns+miuT_ns)*(2*ux_x + uy_y + vx_y)', ' - (miu_ns+miuT_ns)*(vx_x + uy_x + 2*vy_y)', [] };
    fea.phys.ns.eqn.sconv = { 'rho_ns*(u*ux_t + v*uy_t)', 'rho_ns*(u*vx_t + v*vy_t)', [] };
    fea.phys.ns.eqn.seqn = { 'rho_ns*u'' - (miu_ns+miuT_ns)*(2*ux_x + uy_y + vx_y) + rho_ns*(u*ux_t + v*uy_t) + p_x = Fx_ns', 'rho_ns*v'' - (miu_ns+miuT_ns)*(vx_x + uy_x + 2*vy_y) + rho_ns*(u*vx_t + v*vy_t) + p_y = Fy_ns', 'ux_t + vy_t = 0' };
    fea.phys.ns.eqn.vars = { 'Velocity field', 'sqrt(u^2+v^2)';
                             'x-velocity', 'u';
                             'y-velocity', 'v';
                             'Pressure', 'p';
                             'Vorticity', 'vx-uy';
                             'Velocity field', { 'u', 'v' } };
    fea.phys.ns.prop.isaxi = 0;
    fea.phys.ns.prop.artstab.id = 0;
    fea.phys.ns.prop.artstab.id_coef = 0.5;
    fea.phys.ns.prop.artstab.sd = 0;
    fea.phys.ns.prop.artstab.sd_coef = 0.25;
    fea.phys.ns.prop.artstab.ps = 1;
    fea.phys.ns.prop.artstab.ps_coef = 1;
    fea.phys.ns.prop.artstab.iupw = 0;
    fea.phys.ns.prop.turb.model = 'laminar';
    fea.phys.ns.prop.turb.wallf = 1;
    fea.phys.ns.prop.turb.inlet = [];
    fea.phys.ns.prop.active = [ 1;
                                1;
                                1 ];
    fea.phys.ns.prop.intb = 0;
    
    %% Boundary settings
    fea.phys.ns.bdr.sel = [ 1, 4, 1, 2, 1, 1, 1 ];
    fea.phys.ns.bdr.coef = { 'bw_ns', 'u = 0', 'Wall/no-slip', [], { 1, 1, 1, 1, 1, 1, 1;
                             1, 1, 1, 1, 1, 1, 1;
                             0, 0, 0, 0, 0, 0, 0 }, [], { 0, 0, 0, 0, 0, 0, 0;
                             0, 0, 0, 0, 0, 0, 0;
                             0, 0, 0, 0, 0, 0, 0 };
                             'bv_ns', 'u = u_0', 'Inlet/velocity', { 'u_0';
                             'v_0';
                             [] }, { 1, 1, 1, 1, 1, 1, 1;
                             1, 1, 1, 1, 1, 1, 1;
                             0, 0, 0, 0, 0, 0, 0 }, [], { 0, 0, 0, Ux_Velocity, 0, 0, 0;
                             0, 0, 0, Uy_Velocity, 0, 0, 0;
                             0, 0, 0, 0, 0, 0, 0 };
                             'bn_ns', '-n.(-pI + mu(grad u+grad uT)) = 0', 'Neutral outflow/stress boundary', [], { 0, 0, 0, 0, 0, 0, 0;
                             0, 0, 0, 0, 0, 0, 0;
                             0, 0, 0, 0, 0, 0, 0 }, [], { 0, 0, 0, 0, 0, 0, 0;
                             0, 0, 0, 0, 0, 0, 0;
                             0, 0, 0, 0, 0, 0, 0 };
                             'bp_ns', 'p = p_0', 'Outflow/pressure', { [];
                             [];
                             'p_0' }, { 0, 0, 0, 0, 0, 0, 0;
                             0, 0, 0, 0, 0, 0, 0;
                             1, 1, 1, 1, 1, 1, 1 }, { { '-p*nx';
                             '-p*ny';
                             '0' };
                             [] }, { 0, 0, 0, 0, 0, 0, 0;
                             0, 0, 0, 0, 0, 0, 0;
                             0, '0', 0, 0, 0, 0, 0 };
                             'bs_ns', 'n&.u = 0, -n.(-pI + mu(grad u+grad uT)).t = 0', 'Symmetry/slip', [], { 0, 0, 0, 0, 0, 0, 0;
                             0, 0, 0, 0, 0, 0, 0;
                             0, 0, 0, 0, 0, 0, 0 }, [], { 'solve_hook_bdrslip', 'solve_hook_bdrslip', 'solve_hook_bdrslip', 'solve_hook_bdrslip', 'solve_hook_bdrslip', 'solve_hook_bdrslip', 'solve_hook_bdrslip';
                             0, 0, 0, 0, 0, 0, 0;
                             0, 0, 0, 0, 0, 0, 0 } };
    fea.phys.ns.bdr.coefi = { 'bcic_ns', 'n.(F_1-F_2) = 0, F_i=-p_iI + mu_i(grad u_i+grad u_iT)', 'Continuity', [], { 0, 0, 0, 0, 0, 0, 0;
                              0, 0, 0, 0, 0, 0, 0;
                              0, 0, 0, 0, 0, 0, 0 }, [], { 0, 0, 0, 0, 0, 0, 0;
                              0, 0, 0, 0, 0, 0, 0;
                              0, 0, 0, 0, 0, 0, 0 };
                              'bcij_ns', 'u = u_0', 'Prescribed velocity', { 'u_0';
                              'v_0';
                              [] }, { 1, 1, 1, 1, 1, 1, 1;
                              1, 1, 1, 1, 1, 1, 1;
                              0, 0, 0, 0, 0, 0, 0 }, [], { 0, 0, 0, 0, 0, 0, 0;
                              0, 0, 0, 0, 0, 0, 0;
                              0, 0, 0, 0, 0, 0, 0 };
                              'bcir_ns', 'p = p_0', 'Prescribed pressure', { [];
                              [];
                              'p_0' }, { 0, 0, 0, 0, 0, 0, 0;
                              0, 0, 0, 0, 0, 0, 0;
                              1, 1, 1, 1, 1, 1, 1 }, [], { 0, 0, 0, 0, 0, 0, 0;
                              0, 0, 0, 0, 0, 0, 0;
                              0, 0, 0, 0, 0, 0, 0 } };
    fea.phys.ns.bdr.vars = { 'Viscous force, x-component', '(miu_ns+miuT_ns)*(2*nx*ux+ny*(uy+vx))';
                             'Viscous force, y-component', '(miu_ns+miuT_ns)*(nx*(vx+uy)+2*ny*vy)';
                             'Total force, x-component', '-nx*p+(miu_ns+miuT_ns)*(2*nx*ux+ny*(uy+vx))';
                             'Total force, y-component', '-ny*p+(miu_ns+miuT_ns)*(nx*(vx+uy)+2*ny*vy)' };
    fea.phys.ns.prop.intb = 0;
    
    %% Solver
    fea = parsephys( fea );
    fea = parseprob( fea );
    
    fea.sol.u = solvestat( fea, ...
                           'iupw', [ 0, 0, 0 ], ...
                           'linsolv', 'backslash', ...
                           'icub', 'auto', ...
                           'nlrlx', 1, ...
                           'toldef', 1e-06, ...
                           'tolchg', 1e-06, ...
                           'reldef', 0, ...
                           'relchg', 1, ...
                           'maxnit', 20, ...
                           'hook', [], ...
                           'nproc', 4, ...
                           'init', { 'u0_ns', 'v0_ns', 'p0_ns' }, ...
                           'solcomp', [ 1; 1; 1 ] );

    % save image (ux)
    clf('reset');
    img = postplot( fea, ...
              'surfexpr', 'u', ...
              'axis','off',...
              'colorbar','off',...
              'solnum', 1 );
    %               'caxis',[0 6],...
    image = gca;
    ux_save_path = strcat(opt.Ux_path,save_name);
    ux_save_path = strcat(ux_save_path,'.jpg');
    exportgraphics(image, ux_save_path,'Resolution',71);
    
    % save image (uy)
    clf('reset');
    postplot( fea, ...
              'surfexpr', 'v', ...
              'axis','off',...
              'colorbar','off',... 
              'solnum', 1 );
              %               'caxis',[-10 10],...
    image = gca;
    uy_save_path = strcat(opt.Uy_path,save_name);
    uy_save_path = strcat(uy_save_path,'.jpg');
    exportgraphics(image, uy_save_path,'Resolution',71);
    
    % save image (pressure)
    clf('reset');
    postplot( fea, ...
              'surfexpr', 'p', ...
              'axis','off',...
              'colorbar','off',...
              'solnum', 1 );
    %               'caxis',[-500 5000],...
    image = gca;
    pressure_save_path = strcat(opt.P_path,save_name);
    pressure_save_path = strcat(pressure_save_path,'.jpg');
    exportgraphics(image, pressure_save_path,'Resolution',71);
    
    % save subd
    clf('reset');
    plotsubd(fea,...
             'labels', 'off');
    image = gcf;
    subd_path = strcat(opt.Subd_path,save_name);
    subd_path = strcat(subd_path,'.jpg');
    exportgraphics(image,subd_path);

    % save solved file 
    columns = {'x', 'y', 'ux', 'uy', 'p'};
    uxuyp = reshape(fea.sol.u, [], 3);
    table = [fea.grid.p' uxuyp];
    output = array2table(table, 'VariableNames', columns);
    solve_path = strcat(opt.Solve_path,save_name);
    solve_path = strcat(solve_path,'.csv');
    writetable(output,solve_path,'Delimiter', ',','QuoteStrings',true);
end

function offset = generate_random_offset(x_min, x_max, y_min, y_max, size_factor)
    % Adjust the limits internally to ensure the triangle is within bounds
    x_internal_lim = [x_min + size_factor, x_max - size_factor];
    y_internal_lim = [y_min + size_factor, y_max - size_factor];

    % Generate x,y positions within the adjusted limits
    x_center = (x_internal_lim(2) - x_internal_lim(1)) * rand() + x_internal_lim(1);
    y_center = (y_internal_lim(2) - y_internal_lim(1)) * rand() + y_internal_lim(1);
    offset = [x_center, y_center];
end

% Generate triangle function with rotation
function tri = generate_triangle(offset, size_factor, rotation_angle)
    x_center = offset(1);
    y_center = offset(2);

    % Equilateral triangle vertices generation
    height = sqrt(3) * size_factor; % Height of the equilateral triangle
    x = [x_center - size_factor, x_center + size_factor, x_center];
    y = [y_center - height/2, y_center - height/2, y_center + height/2];

    % Center the triangle at (0,0) for rotation
    x = x - x_center;
    y = y - y_center;

    % Rotation matrix
    rotation_matrix = [cos(rotation_angle), -sin(rotation_angle); sin(rotation_angle), cos(rotation_angle)];

    % Apply rotation
    rotated_coords = rotation_matrix * [x; y];

    % Shift the triangle back to its offset position
    x_rotated = rotated_coords(1, :) + x_center;
    y_rotated = rotated_coords(2, :) + y_center;

    % Ensure the triangle does not touch the edges of the total space
    if min(x_rotated) < 0.2 || max(x_rotated) > 2.8 || min(y_rotated) < 0.2 || max(y_rotated) > 1.3
        error('Triangle is too close to the boundary.');
    end

    tri = [x_rotated; y_rotated];
    tri = [tri, tri(:,1)]; % Close the triangle by repeating the first point
end
